---
autoGroup-9: GC垃圾回收
title: G1原理
---
### G1 （Garbage First)
JDK7推出的，JDK8默认未启用，需要自己指定使用

基于分代模型，采用Region模式进行垃圾回收（Region有点像2048那个小游戏的感觉）

是ZGC回收器未投产之前，主推的一款垃圾回收器

::: tip

这里，这位博主写的十分精彩，我就不重复造轮子了

https://www.jianshu.com/p/aef0f4765098

:::

在这里记录一下读这篇文献时，一些自己的理解
#### 跨代引用和RememberSet
RemeberSet并不是只有垃圾回收器G1才有，而是任何垃圾回收器都有的，因为老年代引用年轻代中对象的情况在哪里都能出现

所以也不能让每次进行YoungGC时，再去老年代全部扫描一次，就有了一个RemeberSet

不过至于其他垃圾回收器怎么实现的RemeberSet，目前全网几乎没有文献能详细说明

#### CardTable的维护
1. 对于**写屏障**我个人把它理解成了一个和SQL中触发器的功能类似的东西
2. G1在同Region是不做CardTable维护的，同时空引用也不做


#### 为什么更新RememberSet阶段需要在YoungGC之前完成
因为RemeberSet记录同代之间的引用没什么意义，所以当第一次YoungGC结束后，G1需要扫描一下S区中的内容，看看引用情况，如果第二次YoungGC来了，还没执行完，那么S区中的内容就不准确了

#### 软实时是如何实现的
因为有很多的Region，每次标记完成后，可以把Region排序，一个一个移动，在规定时间内完成多少是多少，完不成的下次继续


#### YoungGC和MixedGC
G1的算法默认会两种回收交替进行，MixedGC也无法单独指定时间，如果G1达到了无法清理的地步，不得不进行FullGC

#### 简单的描述一下G1的工作模式
1. 在年轻代标记，得出待清理的Region列表，STW，进行一次YGC，在规定时间内完成多少是多少
2. 达到堆使用的阈值，准备回收老年代，开始分析S区和老年代的引用关系，更新RememberSet，并赶在下一次YGC之前完成
3. 开始并发标记
4. Remark(类似CMS，不过G1用了更特别的数据结构)
5. 得出待清理Region列表，在规定时间内完成任务，此过程也是STW的，MixedGC