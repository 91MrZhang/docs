(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{456:function(a,t,r){"use strict";r.r(t);var s=r(27),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h3",{attrs:{id:"cms-（concurrent-mark-sweep"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cms-（concurrent-mark-sweep"}},[a._v("#")]),a._v(" CMS （Concurrent-Mark-Sweep)")]),a._v(" "),r("p",[a._v("CMS的好处是低延迟（低STW），并行统计GCRoot")]),a._v(" "),r("p",[a._v("CMS在JDK9已经被废弃了，在JDK14就撤出历史舞台了")]),a._v(" "),r("h3",{attrs:{id:"cms工作流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cms工作流程"}},[a._v("#")]),a._v(" CMS工作流程")]),a._v(" "),r("h4",{attrs:{id:"初始标记阶段（initital-mark）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#初始标记阶段（initital-mark）"}},[a._v("#")]),a._v(" 初始标记阶段（Initital Mark）")]),a._v(" "),r("p",[a._v("先STW一次，"),r("strong",[a._v("仅仅标记能直接关联的GCRoot")])]),a._v(" "),r("h4",{attrs:{id:"并发标记阶段（concurrent-mark）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并发标记阶段（concurrent-mark）"}},[a._v("#")]),a._v(" 并发标记阶段（Concurrent Mark）")]),a._v(" "),r("p",[a._v("与其他线程同步执行，顺着第一步标记的GCRoot向下遍历，找出所有关联对象，因为这一步很耗时，所以并发执行，大大减少STW时间，是CMS关键所在")]),a._v(" "),r("h4",{attrs:{id:"重标记阶段（remark）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重标记阶段（remark）"}},[a._v("#")]),a._v(" 重标记阶段（Remark）")]),a._v(" "),r("p",[a._v("并发标记过程中，其他线程也在执行，有引用更新调整的情况发生，所以需要STW一下，重新标记一次")]),a._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),r("p",[a._v("这里涉及到一个"),r("strong",[a._v("Card Table")]),a._v("的概念")]),a._v(" "),r("p",[a._v("并发标记阶段过程中，出现变更的对象会被记录在Card Table里")]),a._v(" "),r("p",[a._v("这样可以大大提高Remark阶段的效率")])]),a._v(" "),r("h4",{attrs:{id:"并发清除阶段-（concurrent-sweep）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并发清除阶段-（concurrent-sweep）"}},[a._v("#")]),a._v(" 并发清除阶段 （Concurrent Sweep）")]),a._v(" "),r("p",[a._v("标记好之后，再并发清除")]),a._v(" "),r("h5",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),r("p",[a._v("https://www.jianshu.com/p/a88dabfc2f60")]),a._v(" "),r("h3",{attrs:{id:"弊端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#弊端"}},[a._v("#")]),a._v(" 弊端")]),a._v(" "),r("h4",{attrs:{id:"内存碎片"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存碎片"}},[a._v("#")]),a._v(" 内存碎片")]),a._v(" "),r("p",[a._v("因为是并行清理的，只清理垃圾，不能调现有引用的地址，所以无法避免产生许多的内存碎片")]),a._v(" "),r("h4",{attrs:{id:"浮动垃圾"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浮动垃圾"}},[a._v("#")]),a._v(" 浮动垃圾")]),a._v(" "),r("p",[a._v("在清理过程中，可能还会产生新的垃圾，无法避免的，只能等待下一次GC触发")]),a._v(" "),r("h4",{attrs:{id:"触发serial-old清理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触发serial-old清理"}},[a._v("#")]),a._v(" 触发Serial Old清理")]),a._v(" "),r("p",[a._v("老年代内存碎片太多了，没办法担保分配了，会触发Serial Old进行FullGC，而Serial Old又是串行的STW，效率很差\nCMSInitiatingOccupancyFraction是CMS的老年代内存达到一定的百分比之后触发Serial Old的阈值")]),a._v(" "),r("h3",{attrs:{id:"适用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[a._v("#")]),a._v(" 适用场景")]),a._v(" "),r("ol",[r("li",[a._v("追求低延迟的强调用户体验的应用")]),a._v(" "),r("li",[a._v("内存不是特别大的，6G以下，如果内存特别大，那么真触发了一次Serial Old，FullGC大内存很麻烦，影响CMS口碑")])])])}),[],!1,null,null,null);t.default=e.exports}}]);