(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{457:function(e,t,a){"use strict";a.r(t);var r=a(27),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"g1-（garbage-first"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1-（garbage-first"}},[e._v("#")]),e._v(" G1 （Garbage First)")]),e._v(" "),a("p",[e._v("JDK7推出的，JDK8默认未启用，需要自己指定使用")]),e._v(" "),a("p",[e._v("基于分代模型，采用Region模式进行垃圾回收（Region有点像2048那个小游戏的感觉）")]),e._v(" "),a("p",[e._v("是ZGC回收器未投产之前，主推的一款垃圾回收器")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("这里，这位博主写的十分精彩，我就不重复造轮子了")]),e._v(" "),a("p",[e._v("https://www.jianshu.com/p/aef0f4765098")])]),e._v(" "),a("p",[e._v("在这里记录一下读这篇文献时，一些自己的理解")]),e._v(" "),a("h4",{attrs:{id:"跨代引用和rememberset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨代引用和rememberset"}},[e._v("#")]),e._v(" 跨代引用和RememberSet")]),e._v(" "),a("p",[e._v("RemeberSet并不是只有垃圾回收器G1才有，而是任何垃圾回收器都有的，因为老年代引用年轻代中对象的情况在哪里都能出现")]),e._v(" "),a("p",[e._v("所以也不能让每次进行YoungGC时，再去老年代全部扫描一次，就有了一个RemeberSet")]),e._v(" "),a("p",[e._v("不过至于其他垃圾回收器怎么实现的RemeberSet，目前全网几乎没有文献能详细说明")]),e._v(" "),a("h4",{attrs:{id:"cardtable的维护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cardtable的维护"}},[e._v("#")]),e._v(" CardTable的维护")]),e._v(" "),a("ol",[a("li",[e._v("对于"),a("strong",[e._v("写屏障")]),e._v("我个人把它理解成了一个和SQL中触发器的功能类似的东西")]),e._v(" "),a("li",[e._v("G1在同Region是不做CardTable维护的，同时空引用也不做")])]),e._v(" "),a("h4",{attrs:{id:"为什么更新rememberset阶段需要在younggc之前完成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么更新rememberset阶段需要在younggc之前完成"}},[e._v("#")]),e._v(" 为什么更新RememberSet阶段需要在YoungGC之前完成")]),e._v(" "),a("p",[e._v("因为RemeberSet记录同代之间的引用没什么意义，所以当第一次YoungGC结束后，G1需要扫描一下S区中的内容，看看引用情况，如果第二次YoungGC来了，还没执行完，那么S区中的内容就不准确了")]),e._v(" "),a("h4",{attrs:{id:"软实时是如何实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#软实时是如何实现的"}},[e._v("#")]),e._v(" 软实时是如何实现的")]),e._v(" "),a("p",[e._v("因为有很多的Region，每次标记完成后，可以把Region排序，一个一个移动，在规定时间内完成多少是多少，完不成的下次继续")]),e._v(" "),a("h4",{attrs:{id:"younggc和mixedgc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#younggc和mixedgc"}},[e._v("#")]),e._v(" YoungGC和MixedGC")]),e._v(" "),a("p",[e._v("G1的算法默认会两种回收交替进行，MixedGC也无法单独指定时间，如果G1达到了无法清理的地步，不得不进行FullGC")]),e._v(" "),a("h4",{attrs:{id:"简单的描述一下g1的工作模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单的描述一下g1的工作模式"}},[e._v("#")]),e._v(" 简单的描述一下G1的工作模式")]),e._v(" "),a("ol",[a("li",[e._v("在年轻代标记，得出待清理的Region列表，STW，进行一次YGC，在规定时间内完成多少是多少")]),e._v(" "),a("li",[e._v("达到堆使用的阈值，准备回收老年代，开始分析S区和老年代的引用关系，更新RememberSet，并赶在下一次YGC之前完成")]),e._v(" "),a("li",[e._v("开始并发标记")]),e._v(" "),a("li",[e._v("Remark(类似CMS，不过G1用了更特别的数据结构)")]),e._v(" "),a("li",[e._v("得出待清理Region列表，在规定时间内完成任务，此过程也是STW的，MixedGC")])])])}),[],!1,null,null,null);t.default=s.exports}}]);