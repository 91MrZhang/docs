(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{526:function(a,s,t){"use strict";t.r(s);var v=t(27),_=Object(v.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),t("p",[a._v("Hash和B+树索引")]),a._v(" "),t("p",[a._v("指的是索引的实现方式")])]),a._v(" "),t("h3",{attrs:{id:"hash索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash索引"}},[a._v("#")]),a._v(" Hash索引")]),a._v(" "),t("p",[a._v("1、Hash索引的原理跟java的HashMap差不多")]),a._v(" "),t("p",[a._v("2、比如说把username列当索引了，'zhangsan' 通过Mysql的hash算法计算成一个hash值")]),a._v(" "),t("p",[a._v("3、hash值和行地址就可以当一个非聚集索引了")]),a._v(" "),t("p",[a._v("4、Hash索引可以用于精确查找，例如'='、’in'、'＜＝＞',但是没办法范围查找和排序")]),a._v(" "),t("p",[a._v("5、因为可能存在Hash碰撞的原因，所以每插入一条新数据，就得把索引中已有的Hash值遍历一遍")]),a._v(" "),t("p",[a._v("6、适用于给一些业务ID加这个索引，因为通常业务ID都是够长的，不容易产生Hash碰撞，并且精确查询的场合较多")]),a._v(" "),t("h3",{attrs:{id:"b-树索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树索引"}},[a._v("#")]),a._v(" B+树索引")]),a._v(" "),t("p",[a._v("1、二叉树做索引容易不平衡，变成一个链表，平衡二叉树和红黑树又容易太高，增加IO次数，B-树虽然又平衡又控制高度,但是B+树分配的更均匀（根节点元素在子节点是最大值）只在叶子节点存放数据，并且叶子间有指针，适合范围查询")]),a._v(" "),t("p",[a._v("2、因为每次插入新数据时，B+树索引都要重新调整结构，而采用自增主键做B+树索引，则B+树每次的调整改动是最小的，添加到最后面就行")]),a._v(" "),t("h4",{attrs:{id:"innodb、myisam的b-树索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#innodb、myisam的b-树索引"}},[a._v("#")]),a._v(" InnoDB、MyISAM的B+树索引")]),a._v(" "),t("p",[a._v("1、InnoDB这个引擎是在建表时必须得强制来一个B+树的聚集索引的，所以它的叶子节点不光是带索引的键值，还会把同行的数据也带上，如果你没指定主键，Mysql就会找该表的第一个唯一非空索引被作为聚集索引，如果还没有，就拿一个类似隐藏的RowID做聚集索引")]),a._v(" "),t("p",[a._v("2、MyISAM就不同了，它的叶子节点是带索引的键值和对应的行地址")])])}),[],!1,null,null,null);s.default=_.exports}}]);