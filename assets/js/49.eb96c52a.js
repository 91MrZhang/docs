(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{451:function(t,a,r){"use strict";r.r(a);var s=r(27),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"什么是垃圾？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是垃圾？"}},[t._v("#")]),t._v(" 什么是垃圾？")]),t._v(" "),r("p",[t._v("运行的程序中，没有任何指针指向的对象，就是垃圾")]),t._v(" "),r("h3",{attrs:{id:"两种回收方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两种回收方式"}},[t._v("#")]),t._v(" 两种回收方式")]),t._v(" "),r("h4",{attrs:{id:"引用计数法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用计数法"}},[t._v("#")]),t._v(" 引用计数法")]),t._v(" "),r("p",[t._v("一个对象被引用一次计数器就+1，解除引用就-1")]),t._v(" "),r("p",[t._v("好处：计数值减为0了，直接主动释放，效率更高")]),t._v(" "),r("p",[t._v("坏处："),r("strong",[t._v("循环引用的问题不好处理")]),t._v("，例如A引用B，B引用C，C引用D，D引用B，此时A不再引用B，那么B、C、D就应该算为垃圾，但是实际上B、C、D的引用计数值并不为0，无法被回收，占用内存")]),t._v(" "),r("h4",{attrs:{id:"gcroot算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gcroot算法"}},[t._v("#")]),t._v(" GCRoot算法")]),t._v(" "),r("p",[t._v("从根引用开始追溯，递归查找")]),t._v(" "),r("p",[t._v("好处：有效的解决循环引用的我呢提")]),t._v(" "),r("p",[t._v("坏处：耗时久一些")])])}),[],!1,null,null,null);a.default=v.exports}}]);